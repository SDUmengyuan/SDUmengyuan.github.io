<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>华东师范大学数据科学与工程学院夏令营实践项目总结反思</title>
      <link href="/2023/07/13/summarize/"/>
      <url>/2023/07/13/summarize/</url>
      
        <content type="html"><![CDATA[<h1 id="华东师范大学数据科学与工程学院夏令营实践项目总结反思"><a href="#华东师范大学数据科学与工程学院夏令营实践项目总结反思" class="headerlink" title="华东师范大学数据科学与工程学院夏令营实践项目总结反思"></a>华东师范大学数据科学与工程学院夏令营实践项目总结反思</h1><h2 id="项目内容"><a href="#项目内容" class="headerlink" title="项目内容"></a>项目内容</h2><p>部署一个不需要后端服务器和数据库支持的网站，只需要使用 HTML、CSS 和 JavaScript 等前端技术就可以实现的静态博客网站。静态网页博客有很多优点，比如速度快、安全稳定、易于维护等。</p><h2 id="项目框架Hexo"><a href="#项目框架Hexo" class="headerlink" title="项目框架Hexo"></a>项目框架Hexo</h2><h3 id="为什么选用Hexo？"><a href="#为什么选用Hexo？" class="headerlink" title="为什么选用Hexo？"></a>为什么选用Hexo？</h3><p>Hexo是一个<strong>快速、简洁且高效</strong>的静态网站生成引擎，它使用 Node.js 编写，并且提供了<strong>丰富的插件和主题</strong>来扩展和定制博客功能和外观。<strong>本地</strong>可以使用 Hexo 来编写和预览博客内容，通过简单的命令就能将生成的网页上传到 GitHub Pages 上。</p><h2 id="博客主题Butterfly"><a href="#博客主题Butterfly" class="headerlink" title="博客主题Butterfly"></a>博客主题Butterfly</h2><h3 id="为什么选择Butterfly？"><a href="#为什么选择Butterfly？" class="headerlink" title="为什么选择Butterfly？"></a>为什么选择Butterfly？</h3><p>1.Butterfly有<strong>精美的界面设计</strong>和<strong>感官舒适的布局</strong>，并且提供了多种样式和个性化选项，呈现出独特的风格。</p><p>2.Butterfly采用<strong>响应式设计</strong>，能够自适应不同的屏幕尺寸和设备类型，包括桌面电脑、平板电脑和手机等，非常方便使用各个设备访问博客。</p><p>3.Butterfly提供了<strong>丰富的功能</strong>和<strong>插件</strong>支持，包括标签云、评论系统、社交媒体分享按钮、搜索功能等。</p><p>4.Butterfly有一个活跃的<strong>开源社区</strong>，提供了丰富的文档和支持资源。可以通过社区获得技术支持、解决问题，并与其他博客作者交流经验和分享主题定制技巧。</p><h3 id="博客页面布局以及设计思路"><a href="#博客页面布局以及设计思路" class="headerlink" title="博客页面布局以及设计思路"></a>博客页面布局以及设计思路</h3><p>博客整体使用butterfly主题的设计，访问博客的主页会有一个子标题，是随机生成的诗句。右上角是导航栏，可以访问其他页面。</p><p><img src="/2023/07/13/summarize/img1.png"></p><p>下拉之后的布局是左边是个人信息展示，以及文章的分类，标签还有博客相关信息的展示；右边是展示博客中的文章，选取了封面图左右分布的样式，比较美观。</p><p><img src="/2023/07/13/summarize/img2.png" alt="image-20230712233931637"></p><p><img src="/2023/07/13/summarize/img3.png" alt="image-20230712233959251"></p><p>下面是手机端展示的博客页面，内容与网页版相同，由于主题的响应式布局，手机端适应的也比较美观。</p><p><img src="/2023/07/13/summarize/img4.png" alt="image-20230712234632055"></p><h2 id="博客功能实现"><a href="#博客功能实现" class="headerlink" title="博客功能实现"></a>博客功能实现</h2><ul><li><p><strong>文章归档</strong>：展示了文章的概貌以及按照发布时间顺序排列，清晰已观看。</p></li><li><p><strong>文章标签</strong>：展示了所有文章的标签，并且根据标签被使用的次数动态调整标签展示的大小。</p></li><li><p><strong>文章分类</strong>：将文章按照分类进行整理，有利于专题式的管理文章，方便检索。</p></li><li><p><strong>友情链接</strong>：将Hexo网站以及其他可能感兴趣的网站链接进行展示。</p></li><li><p><strong>关于</strong>：展示一些个人信息。</p></li><li><p><strong>搜索</strong>：对文章的内容进行模糊查询。包括文章的标题以及文章的内容。</p><p><img src="/2023/07/13/summarize/img5.png" alt="image-20230713000824644"></p></li></ul><blockquote><p>上述功能均基于butterfly主题框架实现~</p></blockquote><h2 id="遇到的问题以及解决方法"><a href="#遇到的问题以及解决方法" class="headerlink" title="遇到的问题以及解决方法"></a>遇到的问题以及解决方法</h2><h3 id="Hexo框架安装"><a href="#Hexo框架安装" class="headerlink" title="Hexo框架安装"></a>Hexo框架安装</h3><p>在安装Hexo框架时会出现安装过程卡住以及安装失败的问题。以为是nodejs版本以及npm版本的问题，升级之后依然安装失败，查阅资料之后，得出有可能是网络延迟或者电脑安全软件的原因。换了网络以及关掉相应软件后按照成功。</p><h3 id="Hexo初始化"><a href="#Hexo初始化" class="headerlink" title="Hexo初始化"></a>Hexo初始化</h3><p>执行到 <a href="https://so.csdn.net/so/search?q=hexo&spm=1001.2101.3001.7020">hexo</a> init命令，即初始化阶段时，在clone完hexo初始化仓库后，卡在安装依赖的界面，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br><span class="line">INFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">INFO Install dependencies</span><br></pre></td></tr></table></figure><p>解决方法：退出当前命令，在当前文件夹手动执行npm install安装依赖。</p><h3 id="图片显示问题"><a href="#图片显示问题" class="headerlink" title="图片显示问题"></a>图片显示问题</h3><p>在写博客时需要插入图片，可以选用插入外链接的方法，也可以使用本地存储图片的方式。</p><p>我使用的是将图片保存在本地img文件夹，然后在markdown文档中引用的方法，但是一直无法正确显示。</p><p>查找资料找到了以下的解决方案：</p><ul><li><p><strong>设置站点配置_config.yml</strong>：</p><p>post_asset_folder: true</p><p>表示在生成的文章目录中创建一个与文章同名的文件夹，并将文章相关的资源文件（如图像、视频等）放置在该文件夹中。</p></li><li><p><strong>安装插件</strong>：</p><p>npm install hexo-asset-image – save</p></li><li><p><strong>引用图片</strong>：</p><p>运行hexo new “xxxx”来生成markdown博文时，&#x2F;source&#x2F;_posts文件夹内除了xxxx.md文件还有一个同名的文件夹。</p><p>在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片即可。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次项目使用Hexo+Github Page搭建了个人静态博客网站，学习了Hexo的实现命令，掌握了快速搭建博客的方法，使用git进行版本控制，防止代码丢失或者错乱。</p>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解--蚂蚁感冒</title>
      <link href="/2023/07/12/algorithm-ant-cold/"/>
      <url>/2023/07/12/algorithm-ant-cold/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯-2014-省-AB-蚂蚁感冒"><a href="#蓝桥杯-2014-省-AB-蚂蚁感冒" class="headerlink" title="[蓝桥杯 2014 省 AB] 蚂蚁感冒"></a>[蓝桥杯 2014 省 AB] 蚂蚁感冒</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>长 $100$ 厘米的细长直杆子上有 $n$ 只蚂蚁。它们的头有的朝左，有的朝右。</p><p>每只蚂蚁都只能沿着杆子向前爬，速度是 $1$ 厘米 &#x2F; 秒。</p><p>当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。</p><p>这些蚂蚁中，有 $1$ 只蚂蚁感冒了。并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。</p><p>请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个整数 $n(1&lt;n&lt;50)$ 表示蚂蚁的总数。</p><p>接着的一行是 $n$ 个用空格分开的整数 $X_i(-100&lt;X_i&lt;100)$，$X_i$ 的绝对值，表示蚂蚁离开杆子左边端点的距离。正值表示头朝右，负值表示头朝左，数据中不会出现 $0$ 值，也不会出现两只蚂蚁占用同一位置。其中，第一个数据代表的蚂蚁感冒了。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>要求输出 $1$ 个整数，表示最后感冒蚂蚁的数目。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5 -2 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">-10 8 -20 12 25</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p> 这个题就和脑筋急转弯一样<br> 关键要想明白，两个蚂蚁在相撞的时候掉头，其实蚂蚁没有任何区别，速度也一样，其实就相当于两个蚂蚁互相穿过了。因此只要对向而走的蚂蚁一定会被感染。<br> 因此就可以根据感冒的蚂蚁的初始方向进行分类了。<br> <img src="/2023/07/12/algorithm-ant-cold/img1.png"></p><h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;q[i];</span><br><span class="line">    <span class="comment">//先统计感冒蚂蚁的右边向左走和左边向右走的蚂蚁个数</span></span><br><span class="line">    <span class="type">int</span> rtol=<span class="number">0</span>,ltor=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(q[i])&gt;<span class="built_in">abs</span>(q[<span class="number">0</span>]) &amp;&amp; q[i]&lt;<span class="number">0</span>) rtol++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(q[i])&lt;<span class="built_in">abs</span>(q[<span class="number">0</span>]) &amp;&amp; q[i]&gt;<span class="number">0</span>) ltor++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(q[<span class="number">0</span>]&lt;<span class="number">0</span>)&#123;<span class="comment">//感冒的蚂蚁向左走</span></span><br><span class="line">        res+=ltor;</span><br><span class="line">        <span class="keyword">if</span>(ltor) res+=rtol;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res+=rtol;</span><br><span class="line">        <span class="keyword">if</span>(rtol) res+=ltor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法分析 </category>
          
          <category> 题解总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 思维题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解--地宫取宝</title>
      <link href="/2023/07/12/algorithm-getTreasure/"/>
      <url>/2023/07/12/algorithm-getTreasure/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯-2014-省-AB-地宫取宝"><a href="#蓝桥杯-2014-省-AB-地宫取宝" class="headerlink" title="[蓝桥杯 2014 省 AB] 地宫取宝"></a>[蓝桥杯 2014 省 AB] 地宫取宝</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>X 国王有一个地宫宝库。是 $n \times m$ 个格子的矩阵。每个格子放一件宝贝。每个宝贝贴着价值标签。</p><p>地宫的入口在左上角，出口在右下角。</p><p>小明被带到地宫的入口，国王要求他只能向右或向下行走。</p><p>走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。</p><p>当小明走到出口时，如果他手中的宝贝恰好是 $k$ 件，则这些宝贝就可以送给小明。</p><p>请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 $k$ 件宝贝。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一行 $3$ 个整数，用空格分开：$n$，$m$，$k(1 \le n,m \le 50,1 \le k \le 12)$。</p><p>接下来有 $n$ 行数据，每行有 $m$ 个整数 $C_i(0 \le C_i \le 12)$ 代表这个格子上的宝物的价值。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>要求输出一个整数，表示正好取 $k$ 个宝贝的行动方案数。该数字可能很大，输出它对 $1000000007(10^9+7)$ 取模的结果。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 2 2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 3 2</span><br><span class="line">1 2 3</span><br><span class="line">2 1 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>时限 1 秒, 256M。蓝桥杯 2014 年第五届省赛</p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>1.这个题首先要明确，只能向下或者向右走<br>2.格子中的数要比手中拿到的任意数字都要大才能拿这个宝贝，也就是说是价值是严格递增来取的。<br>3.从入口走到出口是恰好拿k件物品<br><img src="/2023/07/12/algorithm-getTreasure/img1.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>,MOD=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">int</span> f[N][N][<span class="number">13</span>][<span class="number">14</span>];</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n,m,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;w[i][j];</span><br><span class="line">            w[i][j]++;<span class="comment">//减少下标是负数的特判，将所有的价值都加一</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][w[<span class="number">1</span>][<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//第一个数取还是不取的方案初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span> &amp;&amp; j==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//循环k</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;=k;u++)&#123;</span><br><span class="line">                <span class="comment">//循环价值</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;=<span class="number">13</span>;v++)&#123;</span><br><span class="line">                    <span class="type">int</span> &amp;val=f[i][j][u][v];</span><br><span class="line">                    val=(val+f[i<span class="number">-1</span>][j][u][v])%MOD;</span><br><span class="line">                    val=(val+f[i][j<span class="number">-1</span>][u][v])%MOD;</span><br><span class="line">                    <span class="keyword">if</span>(u&gt;<span class="number">0</span> &amp;&amp; w[i][j]==v)&#123;<span class="comment">//只有当可以取当前数，并且严格递增也就是取完之后w[i][j]一定是最大值c</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;v;c++)&#123;</span><br><span class="line">                            val=(val+f[i<span class="number">-1</span>][j][u<span class="number">-1</span>][c])%MOD;</span><br><span class="line">                            val=(val+f[i][j<span class="number">-1</span>][u<span class="number">-1</span>][c])%MOD;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">13</span>;i++) res=(res+f[n][m][k][i])%MOD;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法分析 </category>
          
          <category> 题解总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络--物理层</title>
      <link href="/2023/07/11/network-physical/"/>
      <url>/2023/07/11/network-physical/</url>
      
        <content type="html"><![CDATA[<p>物理层是参考模型的第1层，工作环境是<strong>相邻的两台设备</strong>。讲述比特作为信号在信道上递交时的协议，包括信号转换、信道使用等内容。</p><h1 id="一-数据通信的理论基础"><a href="#一-数据通信的理论基础" class="headerlink" title="一.数据通信的理论基础"></a>一.数据通信的理论基础</h1><p>首先给定一个传输介质，信号在传导时有衰减。每种介质都有一个临界值，设为fc，只有当传输信号残留的能量值大于fc，才可以通过信道传递给接收方。</p><p>注意：信号的频率不同衰减的程度也不同，频率越高衰减越快。</p><p>通信系统的任务：<strong>数据→信号→在介质上传输→信号→数据</strong></p><p><strong>信息和数据（0、1比特）不能直接在介质上传输。</strong></p><h2 id="1-相关概念："><a href="#1-相关概念：" class="headerlink" title="1.相关概念："></a>1.相关概念：</h2><p><strong>信道</strong>：用于传输信号的一个物理通道。可以是一个传输导线，也可以是一个频率范围，或几个传输导线的传输能力的复合。</p><p><strong>（介质的）带宽</strong>：传输过程中能量（振幅）不会明显衰减的频率的宽度。对一根导线， （截止频率）。</p><p>带宽：在介质上单位时间内传递的bit位数。</p><p><strong>基准频率</strong>：周期的倒数（每秒发送多少这样的信号）。一种信号包含<strong>一种或多种频率成分</strong>（方波含有很多种频率成分，以示波器为例）。每种成分都是基准频率的倍数。</p><p>当信号在信道中传输时，高于信道截止频率的频率成分将由于能量衰减过多而不能通过信道。通过信道的只能是低于截止频率的成分。（低频部分称为概貌，高频部分称为细节。）</p><p>信号会发生变形，能否准确识别，依赖于通信双方的约定（信号发送设备和信号接收设备的）。通信双方需要根据能够传输过去的频率成分考虑合适的调制（编码）和解调制（解码），即什么样的信号对应什么样的比特（组合）。</p><h2 id="2-数学基础—傅里叶变换"><a href="#2-数学基础—傅里叶变换" class="headerlink" title="2.数学基础—傅里叶变换"></a>2.数学基础—傅里叶变换</h2><p><img src="/2023/07/11/network-physical/img1.png"><br>表示了波的分解与合成。</p><p>其中， f&#x3D;  1&#x2F;T是基本频率， an bn 次谐波 harmonics ）的正弦振幅和余弦振幅，是常数。这种分解称为傅里叶级数（Fourier series ）。利用傅里叶级数可以重构出函数，也就是说，如果己知周期 ，并且给定振幅，则用以上等式进行求和可以得到时间的原始函数 g(t）。</p><h2 id="3-对于带宽有限的信号"><a href="#3-对于带宽有限的信号" class="headerlink" title="3.对于带宽有限的信号"></a>3.对于带宽有限的信号</h2><p>上述数学分析与数据通信的关联在于<strong>实际信道对不同频率信号有不同的影响。</strong></p><p>我们考虑一个特殊的例子：传输 ASCII 字符 。该字符被编码成一个 比特长的字节，发送的比特模式是 01100010 。图 2-1 (a ）的左半部分显示了计算机传输该字符时的电压输出。对该信号进行傅里叶分析，可以得到以下的系数：</p><p><img src="/2023/07/11/network-physical/img2.png"><br>对应频率的传输能力与均方根振幅成正比。<br><img src="/2023/07/11/network-physical/img3.png"><br><strong>带宽</strong>是传输介质的一种物理特性，通常取决于介质的构成、厚度和电线或者光纤的长度。滤波器一般可用来进一步限制信号的带宽。</p><p>一般将从 到某个最大频率的信号称<strong>为基带（bas eband ）信号</strong>，将被搬移并占用某个更大频率范围的信号称为<strong>通带（passband ）信号</strong>，通带信号与所有的无线传输情况一样。</p><p><img src="/2023/07/11/network-physical/img4.png"></p><p>对于数字传输来说，目标是接收到的信号具有足以重构出原始发送比特序列的精度。也就是在传输过去8个谐波的情况，识别方就已经可以识别出这个信号的高低起伏了。全部传过去就造成了速度上的浪费。</p><p>下面看一个例子：约定：每一个周期信号表示8位，信道带宽为3000hz。</p><p><img src="/2023/07/11/network-physical/img5.png"><br>这些数字清楚地表明，要想在语音级电话线上以 9600 bps 的速率发送数据，必须将图 2-1 (a ）所示的信号变换成2-1 （c ）所示的信号。如此精确地接收原始的二进制比特流需要更复杂的工作。应该看到，<strong>即使传输设备没有任何噪声，也不可能以高于 38.4 kbps 的数据速率传输任何二进制信号（没有谐波传过去了）</strong>。换句话说，限制了带宽也就限制了数据传输率，即使对理想的信道也是如此。然而，一些采用了几级电压值的编码模式可以获得更高的数据传输率。</p><h2 id="4-信道的最大传输速率"><a href="#4-信道的最大传输速率" class="headerlink" title="4.信道的最大传输速率"></a>4.信道的最大传输速率</h2><h3 id="尼奎斯特采样定理（理想状态）"><a href="#尼奎斯特采样定理（理想状态）" class="headerlink" title="尼奎斯特采样定理（理想状态）"></a>尼奎斯特采样定理（理想状态）</h3><p>尼奎斯特采样定理给出了数字设备完整接收（保存，能够依赖采样值完整复原）一个模拟信号最多需要的采样次数。</p><p><strong>表达一</strong>：对于一个时间信号f(t)，如果其最大频率为fmax，那么以2fmax的采样频率采样信号，则依赖采样值可以完整复原信号。</p><p><strong>表达二</strong>：任意一个信号通过了一个带宽为B的低通滤波器（只允许低频率成分通过），那么只要进行每秒2B次（确切）采样，就可以依赖采样值完整复原出能够通过的信号（被过滤后的信号）<br><img src="/2023/07/11/network-physical/img6.png"><br> 直观的解释（证明见相关文献）：<br>根据傅里叶变换，每个周期信号可以看作由多个频率不同的正弦函数和余弦函数叠加而成。<br>对每一个正弦（余弦）函数，如果其频率为f，则需要2f个（确切）采样点就可以完全恢复。这两个采样点可以分别对应振幅最大值和最小值，可以明确信号频率及取值（恢复信号需要）。<br>如果采样频率大于2f，不影响信号恢复，但是有冗余。但是冗余采样不会包含更多的信息。<br>如果采样频率小于2f，则会丢失部分信息，无法完全复原信号。进而影响接收识别过程。</p><p><strong>表达三</strong>：给定一个带宽为B的信道，则这个信道的最大数据传输速率为：</p><p><img src="/2023/07/11/network-physical/img7.png"></p><p>其中：</p><p>2B表示信道上的最大采样频率。<br>V表示采样信号被量化时使用的离散等级。即每个采样点有多少个状态。比如两种状态可以表示1位信号，4种状态可以表示2位信号等等。</p><p><img src="/2023/07/11/network-physical/img8.png"></p><p>log2V 是表达采样值时采用的二进制位数。</p><p>这个公式给出了物理介质带宽（Hz）与数字带宽（bps）之间的关系。V取决于发送和接收设备。<br><img src="/2023/07/11/network-physical/img9.png"><br>采用波的角度考虑：<br>这里的左边B表示每个信号的带宽，V的平方表示每个信号有多少个状态。</p><h3 id="香农定理（现实状态）"><a href="#香农定理（现实状态）" class="headerlink" title="香农定理（现实状态）"></a>香农定理（现实状态）</h3><p>对于一个带宽为Bhz、信噪比为S&#x2F;N的信道，则这个信道的最大数据传输速率为：<br><img src="/2023/07/11/network-physical/img10.png"></p><p>两个公式的注解：<br>带宽B实际上为一个信道支持的最大频率fmax与最小频率fmin的差值，即B&#x3D;fmax-fmin。</p><h1 id="二-引导性传输介质"><a href="#二-引导性传输介质" class="headerlink" title="二.引导性传输介质"></a>二.引导性传输介质</h1><h2 id="1-双绞线"><a href="#1-双绞线" class="headerlink" title="1.双绞线"></a>1.双绞线</h2><p>双绞线可以分成几大类。部署在许多办公大楼内的称为 类线（ Category 5 ）或“猫 5 ”(Cat  5）。 5类双绞线由两根绝缘导线轻轻地扭在一起， 对这样的双绞线被套在一个塑料保护套内。塑料外套既保护了双绞线又把多根导线捆在一起。</p><p>到6类为止，所有的双绞线都称为<strong>非屏蔽双绞线（UTP, Unshielded Twisted Pair ）</strong>，这些双绞线仅由导线和绝缘层简单地构成。</p><p>可以双向同时使用的链路称为<strong>全双工 （full-deplex ）链路</strong>，就像双车道一样：相对应地，可以双向使用但一次只能使用一个方向的链路称为<strong>半双工链路 （half-duplex ）</strong>，就像单轨铁路线；第三类，只允许一个方向上传输的链路则称为<strong>单工链路（simplex ）</strong>，就像单行街一样。</p><p><img src="/2023/07/11/network-physical/img11.png"></p><p>图示：有4对双绞线的5类UTP</p><p>主频为125MHZ</p><p><img src="/2023/07/11/network-physical/img12.png"></p><p>由于在传输过程中有噪声，我们在传输时发送方发送的消息到接收方会被衰减，因此在使用两条线，来记录噪声。</p><p><img src="/2023/07/11/network-physical/img13.png"></p><h2 id="2-同轴电缆coaxial-cable"><a href="#2-同轴电缆coaxial-cable" class="headerlink" title="2.同轴电缆coaxial cable"></a>2.同轴电缆coaxial cable</h2><p><img src="/2023/07/11/network-physical/img14.png"></p><p>因为同轴电缆用的是铜芯，而双绞线用的是铜丝，有电阻区别，因此它比非屏蔽双绞线有更好的屏蔽特性和更大的带宽，所以它能以很高的速率传输相当长的距离。</p><p><img src="/2023/07/11/network-physical/img15.png"></p><h2 id="3-光纤"><a href="#3-光纤" class="headerlink" title="3.光纤"></a>3.光纤</h2><p>光纤内部是玻璃纤维</p><!-- ![](https://img-blog.csdnimg.cn/f212ce24a3e64f5690a94948965b9f5a.png) --><h2 id="4-电磁频谱"><a href="#4-电磁频谱" class="headerlink" title="4.电磁频谱"></a>4.电磁频谱</h2><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/53cd5df07152480390a4f9cc9fd81f6f.png) --><p>通过电磁频谱以及公式c&#x3D;波长*频率可以知道，无线电波如果频率取10^6，<br>他的波长是300米，不是很容易被建筑物挡住。但是微波，如果取频率为10^10，那么波长为0.03m，非常容易受到天气等各种干扰。</p><h1 id="三-公共电话交换网络PSTN-Public-Switched-Telephone-Network"><a href="#三-公共电话交换网络PSTN-Public-Switched-Telephone-Network" class="headerlink" title="三.公共电话交换网络PSTN, Public Switched Telephone Network"></a>三.公共电话交换网络PSTN, Public Switched Telephone Network</h1><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/d45d66ad366c43c499aebab8590acd71.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/e3637417827c4dab859ee09a2200a573.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/496e9687e2cc4d96ab2d8bb1403583e2.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/8a06a51e9e6a49ee91bc898e401da910.png) --><p> 网络层次性组织的好处：可以减少查找所需要的数量级。比如整个世界的号码15位，然后都放在一个表中查询，复杂度就是O（10^15），但如果分级查询，在每层需要查询的复杂度都不超过O(10^4)。</p><blockquote><p>针对PSTN要解决的技术问题：1.本地到端局的信号调制解调制问题  2.中间传输的多线路复用问题  3.在交换局的交换技术。</p></blockquote><h2 id="1-本地回路"><a href="#1-本地回路" class="headerlink" title="1.本地回路"></a>1.本地回路</h2><p>传统双线电话线路上<strong>传递模拟信号</strong>。本地回路关注如何使用<strong>模拟信号尽可能快速的传递数据</strong>。主要设备是<strong>调制解调器</strong>，<strong>调制是将数据转换为模拟信号，解调制是将模拟信号转换为数据</strong>。根据发展历史，调制解调器可以分为使用<strong>4k带宽的电话调制解调器</strong>和使用<strong>1.1M带宽的宽带调制解调器（ADSL调制解调器）。</strong></p><h2 id="2-调制解调器："><a href="#2-调制解调器：" class="headerlink" title="2.调制解调器："></a>2.调制解调器：</h2><h3 id="电话调制解调器"><a href="#电话调制解调器" class="headerlink" title="电话调制解调器"></a>电话调制解调器</h3><p>电话调制解调器<strong>使用电话的4k带宽</strong>，所以电话和数据传输不能同时进行。</p><p>第一代使用2400个符号（采样信号），通过调整每个符号能够表达的数据位数不断提高数据传输速率。<br>第二代使用8k个符号（采样信号）。理论上可以达到很高的数据传输速率，但是由于香农定理的限制，极限值为35k或70kbps。</p><h3 id="ADSL调制解调器（非对称数字用户线-ADSL-Asymmetric-DSL-）"><a href="#ADSL调制解调器（非对称数字用户线-ADSL-Asymmetric-DSL-）" class="headerlink" title="ADSL调制解调器（非对称数字用户线 ADSL, Asymmetric DSL ）"></a>ADSL调制解调器（非对称数字用户线 ADSL, Asymmetric DSL ）</h3><p>ADSL调制解调器<strong>使用本地回路的全部1.1M带宽</strong>，电话和数据传输能够同时进行。<br>采用频分多路复用技术将1.1M带宽划分为256个4k信道，一个用于电话传输，5个空闲（隔离），防止语音信号和数字信号相互干扰，其它用于数据传输。用于数据传输的信道根据信道质量动态采用不同的调制速率，大部分信道用于下行数据传输（到用户），小部分信道用于上行数据传输（从用户）。</p><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/9d3da84ba3094fbda94aa1185d3cb541.png) --><p>典型的 ADSL 部署结构如图 2-35 所示。在这种方案中，电话公司的技术人员必须在客户住所安装一个<strong>网络接口设备（NID, Network Interface Device ）</strong>。这个小的塑料盒代表了电话公司财产的终结和客户财产的开始。靠近 NID （有时候组合在一起）是一个分离器（ splitter),分离器是一个模拟滤波器，它将 POTS 使用的 4000Hz 频段与数据分开。 POTS 信号被路由到己有的电话机或者传真机，而数据信号则被路由到 ADSL 调制解调器，。该调制解调器使用数字信号处理器来实现 OFDMo 由于当前大多数的 ADSL 调制解调器都是外置的，所以计算机必须通过高速方式与它相连。通常的做法是，使用以太网、 USB 电缆或者 802.l l 。</p><p>在线路的另一头（即电话公司端局）也要安装一个对应的分离器。在这里，信号中的<br>语音部分被过滤出来后送到正常的语音交换机中。频率在 26kHz 以上的信号则被路由到一<br>种新设备中，这种设备称为<strong>数字用户线路接入复用器（ DSLAM, Digital Subscriber LineAccess Multiplexer ）</strong>。该设备包含一个数字信号处理器，与 ADSL 调制解调器中的一样。一旦从信号中恢复出比特，就可以据此构造出数据包，并将数据包发送给 ISP。</p><h2 id="3-光纤到户"><a href="#3-光纤到户" class="headerlink" title="3.光纤到户"></a>3.光纤到户</h2><p>光纤到户将本地回路升级为光纤，使用光信号传递数据。每大约100个用户的光纤通过分离器&#x2F;组合器复合到一根到端局的光纤上，用户之间通过时分多路复用使用到端局的光纤。</p><h1 id="四-数字调制与多路复用"><a href="#四-数字调制与多路复用" class="headerlink" title="四.数字调制与多路复用"></a>四.数字调制与多路复用</h1><p>数据(Data)：传递（携带）信息的实体，信息(Information)则是数据的内容或解释。<br>–模拟(Analog)数据与数字(Digital)数据</p><p>信号(Signal)：数据的物理量编码（通常为电编码），数据以信号的形式传播。<br>–模拟信号与数字信号<br>–基带( Base band ) 与宽带( Broadband )信号</p><h2 id="1-信道及其主要特征"><a href="#1-信道及其主要特征" class="headerlink" title="1.信道及其主要特征"></a>1.信道及其主要特征</h2><p>1.数字信道和模拟信道</p><p>数字信道：以<strong>数字脉冲</strong>形式（离散信号）传输数据的信道。<br>模拟信道：以<strong>连续模拟信号</strong>形式传输数据的信道。</p><p>2.模拟信号和数字信号</p><p>模拟信号：时间上连续，包含无穷多个值<br>数字信号：时间上离散，仅包含有限数目的预定值</p><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/5313dce6c1d845689a8759a17d46fe83.png) --><p>3.数字数据的传输方式</p><p><strong>基带传输</strong>：不调制，编码后的数字脉冲信号直接在信道上传送。<br>例如：以太网<br><strong>频带传输</strong>：调制成模拟信号后再传送，接收方需要解调<br>例如：通过电话模拟信道传输</p><p>4.数据编码</p><p>不同类型的信号在不同类型的信道上传输有4种组合，每一种相应地需要进行不同的编码处理。</p><!-- ![](https://img-blog.csdnimg.cn/ee79225ed4aa413896b1431d9283ee33.png) --><!-- 5.模拟传输和数字传输 --><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/30295806f4a84a12969ea2bc8a64ab14.png) --><h2 id="2-编码和调制"><a href="#2-编码和调制" class="headerlink" title="2.编码和调制"></a>2.<strong>编码和调制</strong></h2><p>用数字信号承载数字或模拟数据——编码<br>用模拟信号承载数字或模拟数据——调制</p><!-- ![](https://img-blog.csdnimg.cn/fc2d2104cfca497e83ad6e617b7b06d7.png) --><h3 id="数字数据的数字信号编码："><a href="#数字数据的数字信号编码：" class="headerlink" title="数字数据的数字信号编码："></a>数字数据的数字信号编码：</h3><ul><li><p><strong>不归零制</strong>(NRZ，Non-Return to Zero)<br>二进制数字0、1分别用两种电平来表示。<br>常用－5V表示1，＋5V表示0。</p><p>  缺点: 不具备自同步机制，必须使用外同步。</p></li><li><p><strong>曼彻斯特编码</strong>(Manchester code)<br>用电压的变化表示0和1。</p><p>  规定在每个码元的中间发生跳变：高 →低的跳变——0，低→高的跳变——1</p><p>  每个码元中间都要发生跳变，接收端可将此变化提取出来作为同步信号，使接收端的时钟与发送设备的时钟保持一致</p><p>  曼彻斯特编码也称为<strong>自同步码（Self-Synchronizing Code</strong>）。它具有<strong>自同步机制</strong>，无需外同步信号。</p><p>  缺点：需要双倍的传输带宽（即信号速率是数据速率的2倍）。</p></li><li><p><strong>差分曼彻斯特编码</strong>(Differential Manchester code)<br>与曼彻斯特编码相同，在每个码元的中间，信号都会发生跳变；不同之处在于：<br>用在码元开始处有无跳变来表示0和1 ：<br>码元开始处有跳变——0<br>码元开始处无跳变——1</p><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/7239211fc9d04280b223ddf634a15d0a.png) --></li></ul><h3 id="基带传输baseband-transmission-："><a href="#基带传输baseband-transmission-：" class="headerlink" title="基带传输baseband transmission ："></a>基带传输baseband transmission ：</h3><p>即信号的传输占有传输介质上从零到最大值之间的全部频率，而最大频率则取决于信令速率。</p><p><strong>带宽效率：</strong></p><p>如何使用<strong>有限的带宽</strong>传递更多的数据：使用多个信号级别。</p><p>一个带宽为4k的语音级线路，如果只使用高低电平两个状态，则每个信号表示1位，最高数据速率为8k。如果使用4种电平状态，则每个信号表示2位，最高数据速率为16k。<br>曼彻斯特编码每两个状态表示一位，则最高数据传输速率为4k。</p><p><strong>时钟恢复：</strong></p><p>通信双方需要同样速率的时钟才能正确解析信号。</p><p>当通信双方约定好编码方式时，如使用高电平表示1，低电平表示0。还需要约定信号的传输速率，如每秒钟传递1000个信号，则每位的时间长度为0.001秒。只有双方时钟完全一致，接收方才能正确识别解析为1000位。</p><p>但是，两台设备的时钟不可能完全一致，总存在误差。当数据传输速率较低且传输数据量较少时，这种误差可以忽略。否则，就会引起识别的错误。这种现象称为时钟漂移。<strong>曼彻斯特编码</strong>每位携带时钟信息，有利于时钟恢复。</p><p><strong>平衡信号：</strong></p><p>在一段时间内，<strong>正电压与负电压一样多的信号。均值为0</strong>，能够避免直流信号。</p><p>一种构造平衡码的简单方法是使用两个电压级别来表示逻辑 ，比如用＋lV 或－ lV表示1，而用 0v 表示逻辑0 。发送 时，发射器在＋IV 和－ IV 之间选择，使得它们总是达到信号平衡。这种方案称为<strong>双极编码（bipolar encoding ）。</strong></p><h3 id="通带传输passband-ansmission-："><a href="#通带传输passband-ansmission-：" class="headerlink" title="通带传输passband ansmission ："></a>通带传输passband ansmission ：</h3><p>信号占据了以载波信号频率为中心的一段频带。这是无线和光纤信道最常使用的调制方法，因为在这样的传输介质中只能在给定的频带中传输信号。</p><h3 id="数字数据的调制编码："><a href="#数字数据的调制编码：" class="headerlink" title="数字数据的调制编码："></a><strong>数字数据的调制编码：</strong></h3><p>三种常用的调制技术：</p><p> 1） <strong>幅移键控ASK</strong>(Amplitude Shift Keying)，调幅 </p><p>2） <strong>频移键控FSK</strong>(Frequency Shift Keying)，调频</p><p> 3） <strong>相移键控PSK</strong>(Phase Shift Keying) ，调相</p><p>4）正交相移键控（Quadrature Phase Shift Keying）：使用4个偏移</p><p>基本原理：用数字信号对载波的不同参量进行调制。</p><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/75bc07e6d321441f8abac26da2c5d9a3.png) --><p>ASK：用载波的两个不同振幅表示0(0v)和1(+5v)<br>FSK：用载波的两个不同频率表示0(1.2KHz)和1(2.4KHz)<br>PSK：用载波的起始相位的变化表示0 (同相)和1(反相)</p><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/23288745bf9d405f9814b57fda4fbb56.png) --><h2 id="3-多路复用技术"><a href="#3-多路复用技术" class="headerlink" title="3.多路复用技术"></a>3.多路复用技术</h2><h3 id="a-FDM-频分复用-Frequency-Division-Multiplexing"><a href="#a-FDM-频分复用-Frequency-Division-Multiplexing" class="headerlink" title="a.FDM (频分复用)Frequency Division Multiplexing"></a>a.FDM (频分复用)Frequency Division Multiplexing</h3><p>原理：整个传输频带被划分为若干个频率通道，每个用户占用一个频率通道。频率通道之间留有<strong>防护频带。</strong></p><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/989752ad14da4e4a86075f367a9105e6.png) --><p>发送数字数据时完全有可能把频谱更有效率地划分成<strong>没有保护带</strong>。在<strong>正交频分复用<br>(OFDM, Orthogonal Frequency Division Multiplexing ）</strong>中，信道带宽被分成许多独立发送数<br>据的子载波（例如 QAM ）。</p><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/e909f2a885324f94b8c9f27e4797db20.png) --><p>子载波在频域中被紧紧地包裹在一起。因此，从每个子载波发出的信号能扩散到相邻子载波。然而，如图 2-26 所示，每个子载波的频率响应被设计成在相邻子载波的中心为零。因而可以在子载波的中心频率采样而不会受到它们邻居的干扰。为了正常工作，需要一个保护时间来及时重复符号信号的一部分，以便获得所需要的频率响应。然而，这种开销远远少于许多保护带所需的开销。</p><h3 id="b-WDM-波分复用-Wave-Division-Multiplexing"><a href="#b-WDM-波分复用-Wave-Division-Multiplexing" class="headerlink" title="b.WDM (波分复用)Wave Division Multiplexing"></a>b.WDM (波分复用)Wave Division Multiplexing</h3><p>原理：整个<strong>波长频带</strong>被划分为若干个波长范围，每个用户占用一个波长范围来进行传输。</p><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/6a59e977faa3496f811231dea34d321d.png) --><h3 id="c-TDM-时分复用-Time-Division-Multiplexing"><a href="#c-TDM-时分复用-Time-Division-Multiplexing" class="headerlink" title="c.TDM (时分复用)Time Division Multiplexing"></a>c.TDM (时分复用)Time Division Multiplexing</h3><p>原理：把时间分割成小的时间片，每个时间片分为若干个通道（时隙） ，每个用户占用一个通道传输数据。</p><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/2a3acce6c98e49c9b781136fb1c56f1c.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/dd751de8bf2347b0a60da7f84e2fbded.png) --><p>在这种方式下，用户以<strong>循环的方式</strong>轮流工作。每个用户周期性地获得整个带宽非常短的一个时间，图 2-27 给出了三个流通过 TDM 复用的示例。每个输入流的比特从一个固定的时<br>间槽（time slot ）取出并输出到混合流。该混合流以各个流速率的总和速度发送。这种工作方式要求输入流在时间上必须同步。类似于频率保护带，为了适应时钟的微小变化可能要增加保护时间（guard time ）间隔。</p><p>TDM的缺点：某用户无数据发送，其他用户也不能占用该通道，将会造成带宽浪费。<br>改进：统计时分多路复用（STDM），用户不固定占用某个通道，有空槽就将数据放入。</p><p>TDM 完全不同于另一个统计时分复用（STDM, Statistical Time Division<br>Multiplexing ）。就是电信局或者移动公司采用的一种方法，给用户按照统计规律分配带宽。</p><h3 id="d-CDMA-码分复用"><a href="#d-CDMA-码分复用" class="headerlink" title="d.CDMA (码分复用)"></a>d.CDMA (码分复用)</h3><p>码分复用（ CDM,Code Division Multiplexing ）是<strong>扩展频谱（spread spectrum ）</strong>通信的一种形式，它把<strong>一个窄带信号扩展到一个很宽的频带上</strong>。这种方法更能容忍干扰，而且允许来自不同用户的多个<br>信号共享相同的频带。由于码分复用技术最常用于第 个目的，因此它称为<strong>码分多址</strong>(CDMA, Code Division Multiple Access ）。</p><p> 我们来看一个类似的场景：在一个机场候机大厅里，许多人正在两两交谈。 TDM 可以看作是所有的人都聚集在大厅里按顺序进行交谈。FDM 可以看作是大厅里的人以不同的语调交谈，某些语调高些，某些语调低些，所有的交谈可同时进行并相互独立。 CDMA 可以看作是大厅里的每一对交谈使用不同的语言。讲法语的这一对在谈论有关法国的事情，并且把所有与法国无关的内容都当作噪声拒绝掉。因此， CDMA 的关键在于 能够提取出期望的信号，同时拒绝所有其他的信号，并把这些信号当作噪声。</p><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/5b01c44ad07344cb94e5b3933112d51f.png) --><p>假设是要传递ABC三个信号，图中表示的是发送1信号，那么发送0信号就将其进行翻转。对应的ABC 就是所发送信号的正交基。然后现在是A发送了1，B发送了0，C什么也没有发送。信号复合之后得到了S，发送到接收方之后，就在乘以自己对应的正交基，得到sum，如果sum大于0那么接收的信号就是1，小于0接收的信号就是0，等于0就说明没有接收到信号。</p><h1 id="五-交换技术"><a href="#五-交换技术" class="headerlink" title="五.交换技术"></a>五.交换技术</h1><p>交换局内主要设备是<strong>交换机</strong>（交换节点），交换机连接多条线路，主要功能是把一条入境线路上来的呼叫交换到一条出境线路上。从而支持呼叫一直到接收方。本小节主要介绍两种交换技术—<strong>电路交换和数据包交换（分组交换</strong>）–的概念和基本工作原理，实现和使用细节见第五章。</p><h3 id="电路交换："><a href="#电路交换：" class="headerlink" title="电路交换："></a><strong>电路交换：</strong></h3><p>是一种面向连接的工作方式。分为三部：使用前建立一条从发送方到接收方的路径；使用这条路径传输；传输完毕释放路径。</p><p>交换设备在通信双方找出一条实际的物理线路的过程。(最早的电路交换连接是由电话接线员通过插塞建立的，现在则由计算机化的程控交换机实现。虚电路只使用一个子信道)</p><p>特点：数据传输前需要建立一条端到端的通路。<br>呼叫——建立连接——传输——挂断<br><strong>优缺点：</strong><br>建立连接的时间长；<br>一旦建立连接就独占线路，线路利用率低；<br>无纠错机制；<br>建立连接后，传输延迟小。</p><h3 id="分组交换："><a href="#分组交换：" class="headerlink" title="分组交换："></a>分组交换：</h3><p><strong>包（分组）交换</strong>是一种非连接的工作方式。数据被分为多个包（分组），每个包包含完整的<strong>目的地址。</strong>每个包经过交换节点时，交换节点按照当前网络状况（交换表）为其选择一条输出线路。此过程一直持续直到包被传送到目的地。</p><p>将报文划分为若干个大小相等的分组(Packet)进行存储转发。<br>优点：<br>1）存储量要求较小，可以用内存来缓冲分组——速度快；<br>2）转发延时小——适用于交互式通信；<br>3）某个分组出错仅重发该分组——效率高；<br>4）各分组可通过不同路径传输，可靠性高。</p><p>特点：<br>1）数据传输前不需要建立一条端到端的通路。<br>2）有强大的纠错机制、流量控制和路由选择功能。</p><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/d502c45550124d07a4f94db627bea0e2.png) --><p> 1.Internet的核心思想：分组交换，核心技术：存储转发。</p><p> 2.电话线路的前提是实现资源预留。类似于面向连接的过程：建立连接，使用连接，拆除连接。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法--整数二分与浮点数二分</title>
      <link href="/2023/07/10/dichotomy/"/>
      <url>/2023/07/10/dichotomy/</url>
      
        <content type="html"><![CDATA[<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p>二分的本质：找到一个性质能够把整个区间分成两部分，一半满足这个性质，一半不满足这个性质。<br>整数二分有两个模板：<br>主要问题是性质的寻找和区间的不断更新。</p><p><img src="/2023/07/10/dichotomy/img1.png"></p><h3 id="题目–求数的范围"><a href="#题目–求数的范围" class="headerlink" title="题目–求数的范围"></a>题目–求数的范围</h3><p>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。</p><p>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。</p><p>如果数组中不存在该元素，则返回 -1 -1。</p><p>输入格式<br>第一行包含整数 n 和 q，表示数组长度和询问个数。</p><p>第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。</p><p>接下来 q 行，每行包含一个整数 k，表示一个询问元素。</p><p>输出格式<br>共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p><p>如果数组中不存在该元素，则返回 -1 -1。</p><blockquote><p>数据范围<br>1≤n≤100000<br>1≤q≤10000<br>1≤k≤10000</p></blockquote><blockquote><p>输入样例：<br>6 3<br>1 2 2 3 3 4<br>3<br>4<br>5</p></blockquote><blockquote><p>输出样例：<br>3 4<br>5 5<br>-1 -1</p></blockquote><p>&#x3D;&#x3D;这道题就可以用二分来求解&#x3D;&#x3D;<br><strong>思路：</strong><br>首先求第一个数x的位置，可以考虑性质mid为大于等于x，这样如果mid符合要求就一定在x右边，因此要求出x的值，就可以把区间缩小成【l，mid】。如果mid不符合要求就一定在x左边，就可以将区间缩小成【mid+1，r】。<br>同理当我们想求出最后出现的x的位置，可以将性质设定为mid是否小于等于x。如果mid符合要求，那么一定在x的左边，可以将区间缩小成【mid，r】，否则mid一定在x的右边，可以将区间缩小成【l，mid-1】。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid]&gt;=x) r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(q[l]!=x) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;-1 -1&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(q[mid]&lt;=x) l=mid;</span><br><span class="line">                <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;要注意mid取值时是取（l+r）&#x2F;2还是（l+r+1）&#x2F;2。&#x3D;&#x3D;<br>当区间更新为【mid，r】的情况，需要加1。也就是这时l被更新成mid，可以考虑如果l&#x3D;r-1，那么（l+r）&#x2F;2等于l。因此c++里除法是下取整。这样会导致区间更新成【l，r】相当于没有更新，因此会陷入死循环。</p><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><p>浮点数二分比整数二分要简单，不需要考虑边界问题。每次只需要保证l&#x3D;mid或者r&#x3D;mid，使答案一定落在某个区间里即可。</p><h3 id="求算术平方根"><a href="#求算术平方根" class="headerlink" title="求算术平方根"></a>求算术平方根</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*二分法求平方根</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">    <span class="type">double</span> l=<span class="number">0</span>,r=x+<span class="number">1</span>;<span class="comment">//要扩大x的范围，因为有0.01的平方根是0.1的这种平方根比原数大的情况</span></span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">1e-8</span>)&#123;</span><br><span class="line">        <span class="type">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid*mid&gt;=x) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>,l);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求三次方根"><a href="#求三次方根" class="headerlink" title="求三次方根"></a>求三次方根</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*二分法求三次方根</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">double</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="type">double</span> l=<span class="number">-10000</span>,r=<span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">1e-8</span>)&#123;</span><br><span class="line">        <span class="type">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>((mid*mid*mid)&gt;=n) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串读入读出格式处理问题</title>
      <link href="/2023/07/09/string_problems/"/>
      <url>/2023/07/09/string_problems/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯-2018-省-A-航班时间"><a href="#蓝桥杯-2018-省-A-航班时间" class="headerlink" title="[蓝桥杯 2018 省 A] 航班时间"></a>[蓝桥杯 2018 省 A] 航班时间</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小 h 前往美国参加了蓝桥杯国际赛。小 h 的女朋友发现小 h 上午十点出发，上午十二点到达美国，于是感叹到“现在飞机飞得真快，两小时就能到美国了”。</p><p>小 h 对超音速飞行感到十分恐惧。仔细观察后发现飞机的起降时间都是当地时间。由于北京和美国东部有 $12$ 小时时差，故飞机总共需要 $14$ 小时的飞行时间。</p><p>不久后小 h 的女朋友去中东交换。小 h 并不知道中东与北京的时差。但是小 h 得到了女朋友来回航班的起降时间。小 h 想知道女朋友的航班飞行时间是多少。</p><p>对于一个可能跨时区的航班，给定来回程的起降时间。假设飞机来回飞行时间相同，求飞机的飞行时间。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>从标准输入读入数据。</p><p>一个输入包含多组数据。</p><p>输入第一行为一个正整数 $T$，表示输入数据组数。</p><p>每组数据包含两行，第一行为去程的起降时间，第二行为回程的起降时间。</p><p>起降时间的格式如下</p><p><code>h1:m1:s1 h2:m2:s2</code></p><p>或</p><p><code>h1:m1:s1 h3:m3:s3 (+1)</code></p><p>或</p><p><code>h1:m1:s1 h4:m4:s4 (+2)</code></p><p>表示该航班在当地时间 <code>h1</code> 时 <code>m1</code> 分 <code>s1</code> 秒起飞，</p><p>第一种格式表示在当地时间 当日 <code>h2</code> 时 <code>m2</code> 分 <code>s2</code> 秒降落</p><p>第二种格式表示在当地时间 次日 <code>h3</code> 时 <code>m3</code> 分 <code>s3</code> 秒降落。</p><p>第三种格式表示在当地时间 第三天 <code>h4</code> 时 <code>m4</code> 分 <code>s4</code> 秒降落。</p><p>对于此题目中的所有以 <code>h:m:s</code> 形式给出的时间, 保证（$0\le h\le23$，$0\le m,s\le59$）.</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出到标准输出。</p><p>对于每一组数据输出一行一个时间 <code>hh:mm:ss</code>，表示飞行时间为 <code>hh</code> 小时 <code>mm</code> 分 <code>ss</code> 秒。</p><p>注意，当时间为一位数时，要补齐前导零。如三小时四分五秒应写为 <code>03:04:05</code>。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">17:48:19 21:57:24</span><br><span class="line">11:05:18 15:14:23</span><br><span class="line">17:21:07 00:31:46 (+1)</span><br><span class="line">23:02:41 16:13:20 (+1)</span><br><span class="line">10:19:19 20:41:24</span><br><span class="line">22:19:04 16:41:09 (+1)</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">04:09:05</span><br><span class="line">12:10:39</span><br><span class="line">14:22:05</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>保证输入时间合法，飞行时间不超过 $24$ 小时。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这个题没有告诉时差，但实际上与时差无关。<br>给出了去和回的出发时间与返程时间，可以发现如果去的时候飞行时间是<strong>到达时间-出发时间+时差</strong>的话，那么回来的时候就是<strong>到达时间-出发时间-时差</strong>，因此两式相加就可以约掉时差。<br>所以飞行时间就是：</p><blockquote><p><strong>（（end1-begin1）+（end2-begin2））&#x2F;2</strong></p></blockquote><h1 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h1><p>这个题的输入输出都是格式化的，需要使用scanf与printf，格式化输入输出。<br>输入每一行的格式还不统一，我们不方便直接提前数据，因此可以提前读入，判断如果没有（+1&#x2F;+2）的话就给他加上（+0），这样就能统一格式，使用sscanf就可以从字符串中格式化提取数据了。</p><h2 id="sscanf"><a href="#sscanf" class="headerlink" title="sscanf"></a>sscanf</h2><p>函数原型如下：要输入一个字符数组头指针，与格式化内容，最后是要赋予值的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><blockquote><p>要注意scanf不会忽略本行的空格，因此本题还要处理第一行读入n之后的换行。</p></blockquote><h2 id="str-c-str（）"><a href="#str-c-str（）" class="headerlink" title="str.c_str（）"></a>str.c_str（）</h2><blockquote><p>c_str() 函数可以将 const string* 类型 转化为 cons char* 类型</p></blockquote><p>还有时间不方便之间作差，先转换成秒在做差，最后输出的时候再将秒转换成时：分：秒的形式。<br>转换方式如下：</p><blockquote><p>  int hour&#x3D;time&#x2F;3600;<br>        int minute&#x3D;time%3600&#x2F;60;<br>        int second&#x3D;time%60;</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_seconds</span><span class="params">(<span class="type">int</span> h,<span class="type">int</span> m,<span class="type">int</span> s)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h*<span class="number">3600</span>+m*<span class="number">60</span>+s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理读入的字符串</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_time</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//可以判断一下每次读入是不是有(+1)没有的话补上（+0）</span></span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    getline(<span class="built_in">cin</span>,line);</span><br><span class="line">    <span class="keyword">if</span>(line.back()!=<span class="string">&#x27;)&#x27;</span>) line+=<span class="string">&quot; (+0)&quot;</span>;</span><br><span class="line">    <span class="type">int</span> h1,m1,s1,h2,m2,s2,d;</span><br><span class="line">    <span class="built_in">sscanf</span>(line.c_str(),<span class="string">&quot;%d:%d:%d %d:%d:%d (+%d)&quot;</span>,&amp;h1,&amp;m1,&amp;s1,&amp;h2,&amp;m2,&amp;s2,&amp;d);</span><br><span class="line">    <span class="keyword">return</span> get_seconds(h2,m2,s2)-get_seconds(h1,m1,s1)+d*<span class="number">24</span>*<span class="number">3600</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="comment">//由于scanf这个函数不会忽略第一行的回车，因此要处理</span></span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    getline(<span class="built_in">cin</span>,line);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> time=(get_time() + get_time())/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> hour=time/<span class="number">3600</span>;</span><br><span class="line">        <span class="type">int</span> minute=time%<span class="number">3600</span>/<span class="number">60</span>;</span><br><span class="line">        <span class="type">int</span> second=time%<span class="number">60</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02d:%02d:%02d\n&quot;</span>,hour,minute,second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字符串格式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划--背包问题</title>
      <link href="/2023/07/09/DP/"/>
      <url>/2023/07/09/DP/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划之背包问题"><a href="#动态规划之背包问题" class="headerlink" title="动态规划之背包问题"></a>动态规划之背包问题</h1><h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。<br>二维</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v[i],&amp;w[i]);</span><br><span class="line">    <span class="comment">//这里i从1开始取，因为i=0时也就是0个物品可选肯定是0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//必须有等号，因为要能够选择前n个物品，且容量为m</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">             <span class="comment">//注意要判断第i个物品能不能选</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i]) f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[n][m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维转化成一维</p><blockquote><p>注意去掉一维的时候要将j从大到小遍历，因为f[j]更新的时候会使用f[j-v[i]]，如果从小到大更新那么f[j-v[i]]在使用之前就已经被更新过了，因此就会造成结果错误。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v[i];j--)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>有 N 件物品和一个容量是 V 的背包。每件物品能使用无限次。</p><blockquote><p>与0-1背包的对比：</p><p>0-1： f[i][j]&#x3D;max(f[i-1][j],<strong>f[i-1][j-v[i]]</strong>+w[i])<br>完全：f[i][j]&#x3D;max(f[i-1][j]<strong>,f[i][j-v[i]]</strong>+w[i])</p></blockquote><p>二维</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];<span class="comment">//先用f[i-1][j]来更新一遍</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i]) f[i][j]=<span class="built_in">max</span>(f[i][j],f[i][j-v[i]]+w[i]);<span class="comment">//注意这里的状态转换公式</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维转换成一维</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=v[i];j&lt;=m;j++)&#123;</span><br><span class="line">        <span class="comment">//f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]); 因为j是从小到大更新的，因此f[i][j-v[i]]是已经被更新过的，可以使用</span></span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);<span class="comment">//注意这里的状态转换公式</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因此在一维表示的情况下，0-1背包和完全背包的代码的差别就在j是从小到大遍历还是从大到小遍历</strong></p><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>有 N 种物品和一个容量是 V 的背包。<br>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p><p>二维 且数据范围很小的时候，可以直接使用三重循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> v[N],w[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s[i];k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=k*v[i])&#123;</span><br><span class="line">                    f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维变成一维</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> v[N],w[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=s[i];k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=k*v[i])&#123;</span><br><span class="line">                    f[j]=<span class="built_in">max</span>(f[j],f[j-k*v[i]]+k*w[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包的二进制优化"><a href="#多重背包的二进制优化" class="headerlink" title="多重背包的二进制优化"></a>多重背包的二进制优化</h3><p>当数据范围达到10^3的时候，三重循环就会超时，可以考虑使用二进制优化。</p><blockquote><p>数据范围<br>0&lt;N≤1000<br>0&lt;V≤2000<br>0&lt;vi,wi,si≤2000</p></blockquote><p>先来考虑如何将多重背包转化成0-1背包：如果将体积为v，价值为w的s个物品拆开，不看成s个物品处理，而是看成s个1来处理，这样组成的物品就是0-1背包问题了。<br>但是这样1000 * 2000 * 2000复杂度是10^9，依然会超时，因此要考虑不拆成s个1来处理，而是使用2的倍数，可以证明在log(s)的级别拆出的数能够表示出小于等于s的所有数字。</p><blockquote><p>举个例子来说明：<br>比如数字7：可以使用1 2 4的组合来表示出所有小于等于7的数字<br>0 都不选<br>1 选1<br>2 选 2<br>3 选 1 2<br>4 选 4<br>5 选 1 4<br>6 选 2 4<br>7 选 1 2 4</p></blockquote><p>如果是不能恰好是2的幂次组合能够表示的数，比如10，那么最后如果剩下的数比2的幂次小就直接加进来，10的话可以直接拆成1 2 4 3，这样就能保证只能表示出小于等于10的数，因为最大也只是到10。<br><strong>全部拆完之后相当转换成了0-1背包问题</strong></p><p>一维滚动数组：<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Goods</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Goods&gt; goods;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> v,w,s;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s;j*=<span class="number">2</span>)&#123;</span><br><span class="line">            s-=j;<span class="comment">//每次减去j，最后的s剩余加进去即可</span></span><br><span class="line">            goods.<span class="built_in">push_back</span>(&#123;j*v,j*w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            goods.<span class="built_in">push_back</span>(&#123;s*v,s*w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> good:goods)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=good.v;j--)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-good.v]+good.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h3><p>分组背包问题是给定N组物品，每组物品中只能选择一种，放进容量是V的背包中，最大价值是多少。<br>那么分析可知<strong>f[i,j]来表示从前i组物品中选，总价值不超过j的选法</strong>。<br>那么相应的状态转移方程应该是从第i组物品中选哪一个，<strong>f[i,j] &#x3D; max(f[i-1,j],f[i-1,j-v[i,0]]+w[i,0],…..f[i-1.j-v[i,k]]+w[i,k])</strong></p><p>分组背包只能使用3重循环求解组数较小的情况，没有较好的优化方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> v[N][N],w[N][N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s[i];j++)&#123;</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//枚举物品的所有组数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--)<span class="comment">//枚举滚动数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;s[i];k++)<span class="comment">//枚举第i组里面的所有物品</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i][k])</span><br><span class="line">                    f[j]=<span class="built_in">max</span>(f[j],f[j-v[i][k]]+w[i][k]);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法--快速排序与归并排序</title>
      <link href="/2023/07/08/sort/"/>
      <url>/2023/07/08/sort/</url>
      
        <content type="html"><![CDATA[<h1 id="一-快速排序"><a href="#一-快速排序" class="headerlink" title="一 快速排序"></a>一 快速排序</h1><h3 id="快排的基本思想：基于分治"><a href="#快排的基本思想：基于分治" class="headerlink" title="快排的基本思想：基于分治"></a>快排的基本思想：基于分治</h3><blockquote><p>主要思想：<br>根据给定的所有数，<strong>每次</strong>取出一个数x作为分界，每次调整区间，使得左边区间的数都小于等于x，右边区间的数都大于等于x。递归处理左右两段。</p></blockquote><p><strong>基本步骤</strong>：<br>1.确定分界点<br>2.调整区间<br>3.递归处理<br><strong>调整区间的两种方法：</strong> 暴力和双指针做法。<br>暴力：多开辟两个数组a，b，先扫描原数组q，小于等于x的存入a，大于x的存入b。最后将ab按顺序存回q。<br>双指针：不需要额外的空间。指针i从左向右扫描，指针j从右向左扫描。如果i碰到的数小于x那么继续右移，否则停止。j遇到的数大于x那么继续左移，否则停止。当i和j都停止的时候交换i j位置上的数。直到i和j相互穿过停止。</p><h3 id="快排算法模板"><a href="#快排算法模板" class="headerlink" title="快排算法模板"></a>快排算法模板</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[N];<span class="comment">//读入的要排序的数组</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x=q[l+r &gt;&gt; <span class="number">1</span>],i=l<span class="number">-1</span>,j=r+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;the divided number is:&quot;</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) swap(q[i],q[j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q,l,j);</span><br><span class="line">    quick_sort(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;out &quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    quick_sort(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看一下样例输出：</p><!-- ![](https://img-blog.csdnimg.cn/e8d7a8288b224aeaace958a9f2ee100d.png) --><p><img src="/2023/07/08/sort/img1.png"><br>根据输出可以进一步理解，边界x是每一次递归调用时取的。</p><p><strong>注意</strong>在取x的时候使用的位运算，右移，l+r&gt;&gt;1相当于做的除以2的操作，速度要快很多。</p><h1 id="求第k个数"><a href="#求第k个数" class="headerlink" title="求第k个数"></a>求第k个数</h1><p>给定一个长度为 n 的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 k 个数。</p><p>输入格式<br>第一行包含两个整数 n 和 k。</p><p>第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整数数列。</p><p>输出格式<br>输出一个整数，表示数列的第 k 小数。</p><blockquote><p>数据范围<br>1≤n≤100000,<br>1≤k≤n</p></blockquote><blockquote><p>输入样例：<br>5 3<br>2 4 1 5 3</p></blockquote><blockquote><p>输出样例：<br>3</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x=q[l+r &gt;&gt; <span class="number">1</span>],i=l<span class="number">-1</span>,j=r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) swap(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q,l,j);</span><br><span class="line">    quick_sort(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    quick_sort(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,q[m<span class="number">-1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二-归并排序"><a href="#二-归并排序" class="headerlink" title="二 归并排序"></a>二 归并排序</h1><h3 id="归并的基本思想：基于分治"><a href="#归并的基本思想：基于分治" class="headerlink" title="归并的基本思想：基于分治"></a>归并的基本思想：基于分治</h3><p>基本思想：归并排序和快速排序都是分治的思想，但是不同的是快排取的边界值是要排序的数本身，而归并取得是下标。<br>步骤：<br>1.确定分界点 mid&#x3D;（l+r）&#x2F;2<br>2.递归排序左部分和右部分<br>3.归并，左右两部分合二为一</p><blockquote><p>归并的方法：双指针算法。<br>假设左右两部分已经排好序了，每次比较left和right的首位置的数，将比较小的数字存到临时数组里面，直到有一部分的数字已经被扫描完。最后将剩余没有扫描的一部分数字直接加到临时数组中。</p></blockquote><h3 id="归并算法模板"><a href="#归并算法模板" class="headerlink" title="归并算法模板"></a>归并算法模板</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N],temp[N];<span class="comment">//定义额外的数组，在归并的时候使用</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    merge_sort(q,l,mid),merge_sort(q,mid+<span class="number">1</span>,r);<span class="comment">//递归排序</span></span><br><span class="line">    <span class="comment">//归并</span></span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;<span class="comment">//temp数组的下标</span></span><br><span class="line">    <span class="type">int</span> i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j]) temp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span> temp[k++]=q[j++];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) temp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) temp[k++]=q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) q[i]=temp[j];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    merge_sort(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求逆序对的数量"><a href="#求逆序对的数量" class="headerlink" title="求逆序对的数量"></a>求逆序对的数量</h1><p>给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。</p><p>逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i&lt;j 且 a[i]&gt;a[j]，则其为一个逆序对；否则不是。</p><p>输入格式<br>第一行包含整数 n，表示数列的长度。</p><p>第二行包含 n 个整数，表示整个数列。</p><p>输出格式<br>输出一个整数，表示逆序对的个数。</p><blockquote><p>数据范围<br>1≤n≤100000，<br>数列中的元素的取值范围 [1,109]。</p></blockquote><blockquote><p>输入样例：<br>6<br>2 3 4 5 6 1</p></blockquote><blockquote><p>输出样例：<br>5</p></blockquote><p><img src="/2023/07/08/sort/img2.png"><br><img src="/2023/07/08/sort/img3.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N],temp[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=l,j=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    LL res=merge_sort(q,l,mid)+merge_sort(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j]) temp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp[k++]=q[j++];</span><br><span class="line">            res+=mid-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) temp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) temp[k++]=q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) q[i]=temp[j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;merge_sort(q,<span class="number">0</span>,n<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><p>1.c++中数据输入很大时，使用scanf读入比cin读入快很多。<br>2.排序算法的稳定性：指两个数在排序之前和排序之后的相对位置是否变化。<br>    快排不稳定，归并是稳定的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
